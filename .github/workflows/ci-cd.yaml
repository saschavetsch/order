# Workflow name that appears in GitHub Actions UI
name: CI/CD Order

# Define when this workflow will run
on:
  push:
    branches:
      - main      # Trigger on pushes to main branch
      - nom-105-cicd-pipeline
  pull_request:
    branches:
      - main      # Trigger on PRs targeting main branch

jobs:
  build:
    # Specify the runner environment
    runs-on: ubuntu-24.04

    steps:
      # Step 1: Check out the repository code
      - uses: actions/checkout@v4 

      # Step 2: Configure Java Development Kit
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'     # Use Eclipse Temurin distribution
          java-version: '21'          # Specify Java version 21

      # Step 3: Cache Maven dependencies to speed up builds
      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: ~/.m2                                               # Location of Maven cache
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}   # Cache key based on OS and pom.xml
          restore-keys: ${{ runner.os }}-m2                         # Fallback cache key (if path to cache not found)

      # Step 5: Pull latest image of catalog for Playwright tests
      - name: Pull latest image of catalog
        run: docker pull ${{ secrets.DOCKERHUB_USERNAME }}/catalog:latest

      - name: Start catalog service
        run: docker run -d -p 8080:8080 --name catalog-app ${{ secrets.DOCKERHUB_USERNAME }}/catalog:latest

      # Step 4: Build the project using Maven
      - name: Start catalog service container
        # Run Maven Spring-Boot build-image task (includes test and package)
        # First -> check if catalog service is up and running
        # Execute a multi-line script for the run method -> | (pipe)
        run: |
          timeout=300
          while ! curl -s -o /dev/null -w "%{http_code}" http://localhost:8080 | grep -q "404"
          do
            if [ $timeout -le 0 ]; then
              echo "Timed out waiting for catalog service!"
              exit 1
            fi
            echo "Waiting for catalog service to be ready..."
            sleep 5
            timeout=$((timeout - 5))
          done
          echo "Catalog service is ready!"

      # New Step: Build application - skip tests (e2e)
      # Another approach would be needed if there were unit tests in the application
      # Either: Start application and then run all the tests afterwards
      # Or: Change the appliled profile in Java for e2e tests to run them separately
      - name: Build application
        run: mvn clean package spring-boot:build-image jacoco:report -DskipTests

      # New Step: Start application
      - name: Start application
        run: java -jar target/OrderApplication.jar &

      # New Step: Wait for application to start with a multi-line script as above
      - name: Wait for application to start
        run: |
          timeout=300
          while ! curl -s -o /dev/null -w "%{http_code}" http://localhost:8081 | grep -q "200"
          do
            if [ $timeout -le 0 ]; then
              echo "Application failed to start"
              exit 1
            fi
            echo "Waiting for application to start..."
            sleep 5
            timeout=$((timeout - 5))
          done

      # New Step: Run tests
      - name: Run tests
        run: mvn test

      # New Step: Upload test results as artifacts
      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()                        # Always upload test results
        with:
          name: test-reports
          path: target/surefire-reports/
          retention-days: 7

      # New Step: Stop application again
      - name: Stop application
        run: pkill -f 'java -jar target/CatalogApplication.jar'

      - name: Stop and remove other app container
        run: |
          docker stop catalog-app
          docker rm catalog-app

      # Step 6: Authenticate with DockerHub
      # https://hub.docker.com/u/saschavetsch
      - name: Login to DockerHub
        uses: docker/login-action@v3                    # Official Docker login action
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}   # Username from GitHub secrets
          password: ${{ secrets.DOCKERHUB_TOKEN }}      # Access token from GitHub secrets

      # Step 7: Build and push Docker image
      - name: Build and push Docker image
        uses: docker/build-push-action@v3                           # Official Docker build and push action
        with:
          context: .                                                # Build context is root directory
          push: true                                                # Actually push the image
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/order:latest    # Image name and tag

      # Step 8: Generate and publish code coverage report
      - name: Upload JaCoCo coverage report
        uses: actions/upload-artifact@v4      # Action for publishing JaCoCo reports
        with:
          name: jacoco-report
          path: target/site/jacoco/           # Path to JaCoCo report
          retention-days: 7